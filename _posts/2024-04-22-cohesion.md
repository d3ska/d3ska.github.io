---
title: "Cohesion"
categories:
  - Blog
tags:
  - Modularity
  - Cohesion
  - Software Architecture
---

### Cohesion 

Cohesion is a measure of how well the parts of a module fit together. A module is considered cohesive when all its components are closely related and packaged together. 
Breaking the module into smaller parts would lead to increased coupling between modules, as they would need to communicate with each other in order to achieve the desired results.

> Attempting to divide a cohesive module would only result in increased coupling and decreased readability. <br>
> <cite> Larry Constantine 

### Functional cohesion
Every part of the module is related to the other, and the module contains everything essential to function.
<br>

### Sequential cohesion
The output from one part of the module serves as the input to another part. The parts are related because they form a processing pipeline where data flows sequentially from one step to the next.
<br>

### Communicational cohesion
Two modules form a communication chain, where each operates on information and/or contributes to some output. For example, add a record to the database and generate an email based on that information.
<br>

### Procedural cohesion
Two modules must execute code in a particular order.
<br>

### Logical cohesion
A module contains elements that perform similar activities, but the caller selects which activity to execute (often through a control flag or parameter). For example, a utility class with methods `parseXml()`, `parseJson()`, and `parseCsv()` grouped together simply because they all "parse something." The elements share a general category of functionality, but they are otherwise unrelated -- removing one would not affect the others. Logical cohesion ranks low because the grouping is based on a logical categorization rather than an actual functional relationship.
<br>

### Temporal cohesion
Modules are related based on timing dependencies. For example, many systems have a list of seemingly unrelated things that must be initialized at system startup; these different tasks are temporally cohesive.
<br>

### Coincidental cohesion
Elements in a module are not related other than being in the same source file; this represents **the most negative** form of cohesion.
<br>
<br>

### LCOM

Lack of Cohesion of methods is a metric that measures the structural cohesion of a module, typically a component.
In other words, it's the sum of sets of methods not shared via sharing fields.

Consider a class with private fields _a_ and _b_. Many of the methods only access _a_, and many other methods only access _b_.
The _sum_ of the sets of methods not shared via sharing fields (_a_ and _b_) is high; therefore, this class reports a high LCOM score, indicating that it scores high in _lack of cohesion in methods_.
Consider the three classes shown below.

![img]({{site.url}}/assets/blog_images/2023-02-28-cohesion/cohesion-coupling-light.png){: .light }
![img]({{site.url}}/assets/blog_images/2023-02-28-cohesion/cohesion-coupling-dark.png){: .dark }


Fields appear as single letters and methods appear as blocks.<br><br>
In _Class X_, the LCOM score is low, indicating good structural cohesion. <br><br>
_Class Y_, however, lacks cohesion; each of the field/method pairs in _Class Y_ could appear in its own class without affecting behavior.<br><br>
_Class Z_ shows mixed cohesion, where developers could refactor the last field/method combination into its own class.

#### Practical interpretation of LCOM scores

As a rule of thumb: an LCOM value of **1** indicates a perfectly cohesive class -- every method accesses every field, and the class has a single, focused responsibility. As the score increases, it signals that the class likely contains distinct clusters of behavior that could be separated. In practice, I start paying attention when LCOM exceeds **2 or 3** for a class with more than a handful of methods. A very high LCOM score (say, above 5) is a strong indicator that the class is doing too much and should be split. Of course, context matters -- a data-transfer object with many independent getters will naturally have a higher LCOM, and that is acceptable.

<br>

### High vs. Low Cohesion: a code example

A low-cohesion class bundles unrelated responsibilities together:

```java
// Low cohesion: this class handles user data, email sending, AND logging
class UserManager {
    private String userName;
    private String email;
    private List<String> logs;

    void updateUserName(String name) {
        this.userName = name;
    }

    void sendWelcomeEmail() {
        // uses only 'email', has nothing to do with 'logs' or 'userName'
        EmailService.send(email, "Welcome!");
    }

    void addLog(String message) {
        // uses only 'logs', unrelated to user data or email
        logs.add(message);
    }
}
```

A high-cohesion design separates these into focused classes:

```java
// High cohesion: each class has a single, focused responsibility
class User {
    private String userName;
    private String email;

    void updateUserName(String name) {
        this.userName = name;
    }

    String getEmail() {
        return email;
    }
}

class WelcomeEmailSender {
    void send(String email) {
        EmailService.send(email, "Welcome!");
    }
}

class AuditLog {
    private List<String> logs;

    void addLog(String message) {
        logs.add(message);
    }
}
```

In the low-cohesion version, the three methods operate on disjoint sets of fields -- the LCOM score would be high. After splitting, each class has methods that all work with the same fields, resulting in strong cohesion and a low LCOM score.